# StreamAPIExample
Учебный проект для изучения Stream API и закрепления навыков работы с ним. Подразумевает выполнение студентом указанных в коде задач в из //TODO описания.

## Как пользоваться
В классе Main находятся задания для выполнения, помечанные комментарием //TODO. На данный момент прописаны задачи для работы с коллекциями:

* Cat - котики
* Shawarma - шаурма

Для генерации коллекции, например котиков, достаточно в методе main объявить следующий код:
```java
ArrayList<Cat> cats = new CatListGenerator().randomCats(1000);
```
Метод вернёт коллекцию с указанным количеством объектов класса Cat с которой можно будет выполнять дальнейшие операции.

## Справка по StreamAPI
StreamAPI позволяет оперировать с потоком данных (не путать с потоком выполнения) из массивов или коллекций, иными словами, из любого набора данных. Это можно сравнить с тем, как груз перемещается по реке из одного источника и при помощи специальных механизмов можно выбирать только нужные «ящики», переводить их в отдельные русла и собирать их в отдельный набор.
Иными словами, StreamAPI придерживается следующей последовательности работы:
 
![image](https://user-images.githubusercontent.com/11871719/200128913-391dd02c-b3af-4d6f-9cf1-b4bcf2909575.png)

Разберём каждый блок из последовательности:
*	Источник – это набор данных, откуда изначально берутся элемен-ты из которых формируется поток данных для обработки;
*	Промежуточный оператор – это некоторый метод, который мо-жет принимать на вход анонимную (лямбда) функцию, описываю-щую какое именно действие надо произвести над каждым из элементов. Например, фильтрацию элементов по определённому условию. Все промежуточные операторы возвращают новый объект типа Stream;
*	Терминальный оператор – к нему относятся методы, которые либо ничего не возвращают (void), либо возвращают объекты других типов.

Разумеется, между источником и терминальным оператором может быть последовательность операторов любой длины. 

Более того, StreamAPI это реализация **монады** – паттерна функционального программирования, в котором происходит композиция (то есть вы-страивание в цепочки) действий, которые иначе были бы разделены строками небезопасного и избыточного кода. 

### Основные методы StreamAPI

```java
.filter(Predicate<T> P)
``` 
фильтрует набор данных по заданному предикату (условию) и возвращает новый поток данных соответствующий условию. 
Предикат может задаваться как ссылкой на анонимную функцию, так и внутри параметра фильтра. Метод фильтра является в некотором роде «входной точкой» так как позволяет ограничить выборку данных и продол-жать манипуляцию уже на новом наборе данных. 
```java
.distinct() 
```
возвращает набор данных, исключая все дубликаты. Работает это следующим образом. По умолчанию, в каждом классе есть методы .equals(Object obj) и hashCode(), неявно наследуемые от суперкласса Object. Эти методы нужны для сравнения двух объектов между собой и по умолчанию сравниваются по значению их ссылок. 
```java
.min/.max(Comparator<? super T> c)
```
возвращают объект типа Optional<T>, который представляет собой контейнер, внутри которого лежит объект с минимальным или максимальным значением свойства из данного набора.
```java
Comparator<? super T>
```
это ещё один функциональный интерфейс, предназначенный для сравнения объектов по значениям их свойств. 
Для примера, в описании интерфейса существует метод по умолчанию .comparingInt, который принимает целочисленные значения и использует статический метод .compare у класса Integer для сравнения двух чисел.
